# .bashrc-extra for OS X and Ubuntu
# ====================================================================
# - zheng.iao@icloud.com
# Iterm2 shell integration
if [ ! -e ~/.iterm2_shell_integration.bash ]; then
  curl -L https://iterm2.com/shell_integration/bash -o ~/.iterm2_shell_integration.bash
fi
source ~/.iterm2_shell_integration.bash

# SSH-Agent
_stsagent() {
  local SSH_ENV="$HOME/.ssh/environment"
  echo "Initialising new SSH agent..."
  /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
  echo succeeded
  chmod 600 "${SSH_ENV}"
  . "${SSH_ENV}" > /dev/null
  /usr/bin/ssh-add;
  /usr/bin/ssh-add -K ~/.ssh/*.pem;
}

stsagent() {
  local SSH_ENV="$HOME/.ssh/environment"
  if [ -f "${SSH_ENV}" ] ; then
    . "${SSH_ENV}" > /dev/null
#ps ${SSH_AGENT_PID} doesn't work under cywgin
    ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
    _stsagent;
  }
    else
    _stsagent;
  fi
}

if [ "$PLATFORM" = 'Darwin' ]; then
  stsagent
fi

# Alias
#-------------------------------------------------------------------------------

if [ "$PLATFORM" = 'Darwin' ]; then
# Desktop Programs
  alias photoshop="open -a /Applications/Adobe\ Photoshop\ CC\ 2018/Adobe\ Photoshop\ CC\ 2018.app"
  alias acrobat="open -a /Applications/Adobe\ Acrobat\ DC/Adobe\ Acrobat.app"

# Show/hide hidden files (for Mac OS X Mavericks)
  alias showhidden="defaults write com.apple.finder AppleShowAllFiles TRUE"
  alias hidehidden="defaults write com.apple.finder AppleShowAllFiles FALSE"

# Get rid of those pesky .DS_Store files recursively
  alias dsclean='find . -type f -name .DS_Store -exec rm -f {} \;'

# Get rid of those pesky .DS_Store files recursively
  alias dlclean='rm -rf ~/Downloads/*'

# Flush your dns cache
  alias flush='dscacheutil -flushcache'
fi
# Repository management
#-------------------------------------------------------------------------------
# Given a path to a folder containing some git repos, compute the
# names of the folders which actually do contain git repos.
_fdrepo() {
  local dirname_cmd
  if [ "$PLATFORM" == "Darwin" ]; then  # macOS
    dirname_cmd="gdirname"
  elif [ "$PLATFORM" == "Linux" ]; then  # Linux
    dirname_cmd="dirname"
  fi
	# https://stackoverflow.com/questions/23356779/how-can-i-store-find-command-result-as-arrays-in-bash
	git_directories=()
	while IFS=  read -r -d $'\0'; do
		git_directories+=("$REPLY")
	done < <(find $1 -maxdepth 2 -type 'd' -name ".git" -print0 2>/dev/null)

	for i in ${git_directories[*]}; do
		if [[ ! -z $i ]]; then
    		$dirname_cmd -z $i | xargs -0 -L1
    fi
  done
}

# List all the git repos in the path.
lsrepo () {
    local path=$1
    local repo
    for repo in $(_fdrepo $path) ; do
        echo ${repo} ":" $(git -C ${repo} symbolic-ref HEAD | sed -e "s/^refs\/heads\///")
    done
}

# Make a automatic commit if within a git repo.
# The commitment message can be from the stdin or generated from git status.
cmrepo() {
  local commit_message
  is_in_git_repo || return
  if ! git diff-index --quiet $(git write-tree) -- || [ -n "$(git status --porcelain)" ]; then
    echo "Attempt automatic commit ... ";
    git add -A;
    git status -sb;
    echo -n "Input the commit message: ";
    read commit_message;
    if [[ ! -n "$commit_message" ]]; then
      commit_message=$(LANG=C git -c color.status=false status -s);
    fi;
    echo "Commit message: "; echo "$commit_message"; echo;
    echo "$commit_message" | git commit -F -;
  fi
  git push -v
}

# Create a prject folder based on the input information
prit() {
  local answer project_type
  local project_name person_name
  local course_number course_semester course_year
  local dir_name
  local proj_path

  echo -n "Is this a (r)esearch/(a)ward/(t)alk/s(e)rvice/(c)ourse/(s)tudent/(p)ersonal? "
  old_stty_cfg=$(stty -g)
  stty raw -echo ; answer=$(head -c 1) ; stty $old_stty_cfg

  if echo "$answer" | grep -iq "^r" ;then
    project_type="project"
  elif echo "$answer" | grep -iq "^a" ;then
    project_type="award"
  elif echo "$answer" | grep -iq "^t" ;then
    project_type="talk"
  elif echo "$answer" | grep -iq "^e" ;then
    project_type="service"
  elif echo "$answer" | grep -iq "^c" ;then
    project_type="course"
  elif echo "$answer" | grep -iq "^s" ;then
    project_type="student"
  elif echo "$answer" | grep -iq "^p" ;then
    project_type="personal"
  else
    echo "invalid semester"
    exit 1
  fi

  if echo "$answer" | grep -Eiq "^s|^p" ;then
    echo -n "\nType in the name of the person(s): "
    read person_name
    person_name="${person_name// /_}"

    echo -n "Type in the name of the project: "
    read project_name
    project_name="${project_name// /_}"

  elif echo "$answer" | grep -Eiq "^c" ;then
    echo -n "\nType in the course number: "
    read course_name
    course_name="${course_name// /_}"

    echo -n "Type in the year: "
    read course_year
    course_year="${course_year// /_}"

    echo -n "Is this a (s)pring/s(u)mmer/(f)all course? "
    old_stty_cfg=$(stty -g)
    stty raw -echo ; semester=$(head -c 1) ; stty $old_stty_cfg

    if echo "$semester" | grep -iq "^s" ;then
      course_semester="spring"
    elif echo "$semester" | grep -iq "^u" ;then
      course_semester="summer"
    elif echo "$semester" | grep -iq "^f" ;then
      course_semester="fall"
    else
      echo "invalid semester"
      exit 1
    fi
  elif echo "$answer" | grep -Eiq "^r|^a|^t" ;then
    echo -n "\nType in the name of the project: "
    read project_name
    project_name="${project_name// /_}"
  fi

  if [[ -n "$course_name" ]]; then
    dir_name="$project_type"_"$course_name"_"$course_year"_"$course_semester"
  elif [[ -n "$person_name" ]]; then
    dir_name="$project_type"_`date +%Y_%m_%d`_"$person_name"_"$project_name"
  else
    dir_name="$project_type"_`date +%Y_%m_%d`_"$project_name"
  fi
  dir_name="${dir_name%_}"

  if [[ "$project_type" == "course" ]]; then
    proj_path=$HOME/Documents/teaching/"$dir_name"
    git_branch="course"
  elif [[ "$project_type" == "personal" ]]; then
    proj_path=$HOME/Documents/personal/"$dir_name"
    git_branch="project"
  elif [[ "$project_type" == "student" ]]; then
    proj_path=$HOME/Documents/students/"$dir_name"
    git_branch="project"
  elif [[ "$project_type" == "services" ]]; then
    proj_path=$HOME/Documents/services/"$dir_name"
    git_branch="project"
  elif [[ ("$project_type" == "project") || ("$project_type" == "award") || ("$project_type" == "talk") ]]; then
    proj_path=$HOME/Documents/research/"$dir_name"
    git_branch="project"
  fi

  if [[ "$project_type" == "personal" ]]; then
    mkdir -p "$proj_path"
  else
    git_repo="https://github.com/gustybear/templates.git"
    git clone --depth=1 -b "$git_branch" "$git_repo" "$proj_path"
    make --directory="$proj_path" init
  fi
}

# Check project status in a batch
prst() {
  local current_dir=${PWD}
  local repos=$(_fdrepo "${HOME}/Documents/* ${HOME}/.dotfiles")
  for dir in ${repos};
  do
      echo "Checking status of ${dir}...";
      cd ${dir} && git status -sb;
  done
  cd ${current_dir}
}

# Pull projects from remote
prpl() {
  local current_dir=${PWD}
  local repos=$(_fdrepo "${HOME}/Documents/* ${HOME}/.dotfiles")
  for dir in ${repos};
  do
      echo "Pulling updates of ${dir} from remote...";
      cd ${dir} && git pull;
  done
  cd ${current_dir}
}

# Update projects to remote
prup() {
  local current_dir=${PWD}
  local repos=$(_fdrepo "${HOME}/Documents/* ${HOME}/.dotfiles")
  for dir in ${repos};
  do
      echo "Updating ${dir} to remote...";
      cd ${dir} && cmrepo;
  done
  cd ${current_dir}
}


# Update website {{{3
wbup() {
  local current_dir=${PWD}
  local web="${HOME}/Documents/__websites"
  local repos=$(_fdrepo "${HOME}/Documents/*")
  if [ -z  ${web} ]; then
    echo "No website folder"
    for dir in ${repos};
    do
      (echo "Updating materials..."; make -C ${dir} publish_s3)
    done
  else
    echo "Updating website...";
    make -C ${web} publish;
  fi
  cd ${current_dir}
}

# Git
# --------------------------------------------------------------------
# Creating or append git ignore by query gitignore.io
gi() {
  result=$(curl "https://www.gitignore.io/api/$1" 2>/dev/null)

  if [[ $result =~ ERROR ]]; then
    echo "Query '$1' has no match. See a list of possible queries with 'gi list'"
  elif [[ $1 == list ]]; then
    echo "Possible search keywords: "
    echo "$result"
  else
    echo "Iterms to add:"
    echo "$result"
    if [[ -f .gitignore ]]; then
      result=`echo "$result" | \
              grep -v -e "# Created by https://www.gitignore.io" \
                      -e "# End of https://www.gitignore.io" `
      echo ".gitignore already exists, appending"
      echo "$result" >> .gitignore
    else
      echo "$result" > .gitignore
    fi
  fi
}

# fzf extensions
# --------------------------------------------------------------------
# Use ~~ as the trigger sequence instead of the default **
# cd to the project folders using fzf
fpr() {
  local dir
  dir=$(_fdrepo "${HOME}/Documents/* ${HOME}/.dotfiles" |
  fzf-tmux --preview-window up:75% \
    --preview 'cd {}; echo "git summary";
              LANG=C git -c color.status=false status -sb; 
              echo;
              tree -C {} | head -200' \
    --select-1) &&
  cd ${dir}
}

# Todo.sh task search
ftodo() {
  local out task key email
  todo.sh ls | awk '$1~/^[0-9]+$/' |
  fzf-tmux --ansi --multi --no-sort --reverse |
  sed 's#.*: \(message://[^ ]\{0,\}\) .*#\1#' |
  xargs open -a "Mail"
          # xargs $open -a Mail
}

# Safari history search
fsafari() {
  local cols sep
  cols=$(( COLUMNS / 3 ))
  sep='{::}'

  cp -f ~/Library/Safari/History.db /tmp/h

  sqlite3 -separator $sep /tmp/h \
    "select substr(id, 1, $cols), url
     from history_items order by visit_count_score desc" |
  awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}'  |
  fzf-tmux --ansi --multi | sed 's#.*\(https*://\)#\1#' \"{}\" | xargs open
}

# Zotero pdf search
fzotero() {
    local DIR open
    declare -a already
    DIR="${HOME}/Cloud/Zotero/cache/pdftotext"
    mkdir -p "${DIR}"
    if [ "$(uname)" = "Darwin" ]; then
        open=open
    else
        open="gio open"
    fi

    {
    ag -ag ".pdf$|.html$" "${HOME}/Cloud/Zotero/storage"; # fast, without pdftotext or html2text
    ag -ag ".pdf$|.html$" "${HOME}/Cloud/Zotero/storage" \
    | while read -r FILE; do
        local EXPIRY HASH CACHE
        HASH=$(shasum "$FILE" | cut -c 1-32)
        # Remove duplicates (file that has same hash as already seen file)
        [ ${already[$HASH]+abc} ] && continue # see https://stackoverflow.com/a/13221491
        already[$HASH]=$HASH
        EXPIRY=$(( 86400 + $RANDOM * 20 )) # 1 day (86400 seconds) plus some random
        if [ "$(head -c 4 "$FILE")" == "%PDF" ]; then
          CMD="pdftotext -f 1 -l 1 -layout '$FILE' - 2>/dev/null | tr \"\n\" \"_\" "
        else
          CMD="html2text -ascii -nobs '$FILE' - 2>/dev/null | tr \"\n\" \"_\" "
        fi
        CACHE="$DIR/$HASH"
        test -f "${CACHE}" && [ $(expr $(date +%s) - $(date -r "$CACHE" +%s)) -le $EXPIRY ] || eval "$CMD" > "${CACHE}"
        echo -e "$FILE\t$(cat ${CACHE})"
    done
    } | fzf -e -d '\t' \
        --preview-window up:75% \
        --preview '
                v=$(echo {q} | tr " " "|");
                echo {1} | grep -E -e "^" -e"$v" -i --color=always;
                if [ "$(head -c 4 {1})" == "%PDF" ]; then pdftotext -f 1 -l 1 -layout {1} - ; else html2text -ascii -nobs {1} - ; fi | grep -E -e"^" -e"$v" -i --color=always' \
        | awk 'BEGIN {FS="\t"; OFS="\t"}; {print "\""$1"\""}' \
        | xargs $open > /dev/null 2> /dev/null
}

# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
export PATH="$PATH:$HOME/.rvm/bin"

[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
